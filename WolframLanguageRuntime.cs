/*
	This file was generated automatically from the SDK C headers by ClangSharpPInvokeGenerator:

		dotnet tool install --global ClangSharpPInvokeGenerator --version 20.1.2.1
*/

using System.Runtime.InteropServices;
using System.Diagnostics;
using System;

namespace WolframLanguageRuntime
{
	public class WLR
	{
		public enum wlr_error_type
		{
			WLR_SUCCESS = 0,
			WLR_ALLOCATION_ERROR = 1,
			WLR_UNEXPECTED_TYPE = 2,
			WLR_ERROR_EXPRESSION = 3,
			WLR_MISCELLANEOUS_ERROR = 4,
			WLR_OUT_OF_BOUNDS = 5,
			WLR_SIGNING_ERROR = 6,
			WLR_UNSAFE_EXPRESSION = 7,
			WLR_MALFORMED = 8,
			WLR_RUNTIME_NOT_STARTED = 9,
		}

		public enum wlr_license_type
		{
			WLR_SIGNED_CODE_MODE = 0,
			WLR_LICENSE_OR_SIGNED_CODE_MODE = 1,
		}

		public enum wlr_version_type
		{
			WLR_VERSION_1 = 0,
		}

		public enum wlr_application_type
		{
			WLR_EXECUTABLE = 0,
			WLR_DYNAMIC_LIBRARY = 1,
		}

		public enum wlr_containment_type
		{
			WLR_CONTAINED = 0,
			WLR_UNCONTAINED = 1,
		}

		public unsafe partial struct wlr_runtime_configuration
		{
			[NativeTypeName("mint")]
			public int argumentCount;

			[NativeTypeName("char **")]
			public sbyte** arguments;

			[NativeTypeName("wlr_containment_t")]
			public wlr_containment_type containmentSetting;
		}

		public static unsafe partial class Methods
		{
			private const string sdkDynamicLibraryName = "StandaloneApplicationsSDK_Shared.dll";

			[DllImport(sdkDynamicLibraryName, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
			[return: NativeTypeName("wlr_err_t")]
			public static extern wlr_error_type wlr_sdk_StartRuntime([NativeTypeName("wlr_application_t")] wlr_application_type applicationType, [NativeTypeName("wlr_version_t")] wlr_version_type version, [NativeTypeName("wlr_license_t")] wlr_license_type licenseType, [NativeTypeName("const char *")] sbyte* layoutDirectory, [NativeTypeName("const wlr_runtime_conf *")] wlr_runtime_configuration* configuration);

			[DllImport(sdkDynamicLibraryName, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
			[return: NativeTypeName("wlr_expr")]
			public static extern void* wlr_String([NativeTypeName("const char *")] sbyte* @string);

			[DllImport(sdkDynamicLibraryName, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
			[return: NativeTypeName("wlr_expr")]
			public static extern void* wlr_Eval([NativeTypeName("wlr_expr")] void* expression);

			[DllImport(sdkDynamicLibraryName, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
			public static extern void wlr_ReleaseExpression([NativeTypeName("wlr_expr")] void* detachedExpression);

			[DllImport(sdkDynamicLibraryName, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
			[return: NativeTypeName("wlr_err_t")]
			public static extern wlr_error_type wlr_StringData([NativeTypeName("wlr_expr")] void* expression, [NativeTypeName("char **")] sbyte** resultData, [NativeTypeName("mint *")] int* resultLength);

			[DllImport(sdkDynamicLibraryName, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
			[return: NativeTypeName("wlr_expr")]
			public static extern void* wlr_ParseExpression([NativeTypeName("wlr_expr")] void* inputString);

			[DllImport(sdkDynamicLibraryName, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
			[return: NativeTypeName("wlr_expr")]
			public static extern void* wlr_VariadicE(void* expressionHead, [NativeTypeName("mint")] long childElementNumber, __arglist);

			[DllImport(sdkDynamicLibraryName, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
			[return: NativeTypeName("wlr_expr")]
			public static extern void* wlr_Symbol([NativeTypeName("const char *")] sbyte* symbolName);

			[DllImport(sdkDynamicLibraryName, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
			public static extern void wlr_CreateExpressionPool();

			[DllImport(sdkDynamicLibraryName, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
			public static extern void wlr_ReleaseExpressionPool();

			[DllImport(sdkDynamicLibraryName, CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
			public static extern void wlr_Release(void* data);
		}

		// The following is machinery (unrelated to the standalone applications SDK) generated by ClangSharpPInvokeGenerator ...

		/// <summary>Defines the annotation found in a native declaration.</summary>
		[AttributeUsage(AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]
		[Conditional("DEBUG")]
		internal sealed partial class NativeAnnotationAttribute : Attribute
		{
			private readonly string _annotation;

			/// <summary>Initializes a new instance of the <see cref="NativeAnnotationAttribute" /> class.</summary>
			/// <param name="annotation">The annotation that was used in the native declaration.</param>
			public NativeAnnotationAttribute(string annotation)
			{
				_annotation = annotation;
			}

			/// <summary>Gets the annotation that was used in the native declaration.</summary>
			public string Annotation => _annotation;
		}

		/// <summary>Defines the type of a member as it was used in the native signature.</summary>
		[AttributeUsage(AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.ReturnValue, AllowMultiple = false, Inherited = true)]
		[Conditional("DEBUG")]
		internal sealed partial class NativeTypeNameAttribute : Attribute
		{
			private readonly string _name;

			/// <summary>Initializes a new instance of the <see cref="NativeTypeNameAttribute" /> class.</summary>
			/// <param name="name">The name of the type that was used in the native signature.</param>
			public NativeTypeNameAttribute(string name)
			{
				_name = name;
			}

			/// <summary>Gets the name of the type that was used in the native signature.</summary>
			public string Name => _name;
		}
	}
}
